# frozen_string_literal: true

module Integrations
  module Ga4ghWesApi
    API_SERVER_ENDPOINT_PATH = 'ga4gh/wes/'
    module V1
      # REST API spec for versioning
      API_SERVER_ENDPOINT_VERSION = 'v1/'
      # Creates a Faraday connection to Ga4gh WES API
      #
      # Additional headers set in credentials file as ga4gh_wes:headers as a Hash
      # Authorization bearer token set in credentials file as ga4gh_wes:oauth_token
      class ApiConnection
        include ApiExceptions

        attr_reader :api_endpoint

        # @param api_server_url [String] Optional: API Server url without endpoint path.
        #   Path is then generated by REST versioning standard. ex: 'http://localhost:7500/'
        # Default: server url with endpoint is set from credentials file as ga4gh_wes:server_url_endpoint
        def initialize(api_server_url = nil)
          @api_endpoint =
            if api_server_url.present?
              "#{api_server_url}#{Ga4ghWesApi::API_SERVER_ENDPOINT_PATH}#{V1::API_SERVER_ENDPOINT_VERSION}"
            elsif Rails.configuration.ga4gh_wes_server_endpoint.present?
              Rails.configuration.ga4gh_wes_server_endpoint
            else
              "http://www.example.com/#{Ga4ghWesApi::API_SERVER_ENDPOINT_PATH}#{V1::API_SERVER_ENDPOINT_VERSION}"
            end
          Rails.logger.info @api_endpoint
        end

        def conn # rubocop:disable Metrics/MethodLength
          headers = {}
          extra_headers = Rails.application.credentials.dig(:ga4gh_wes, :headers)
          headers = headers.merge(extra_headers) unless extra_headers.nil?

          Faraday.new(
            url: @api_endpoint,
            headers:
          ) do |f|
            # proc so auth is evaluated on each request
            f.request :authorization, 'Bearer', -> { Rails.application.credentials.dig(:ga4gh_wes, :oauth_token) }
            f.request :multipart
            f.request :url_encoded
            f.response :logger, Rails.logger # logs request and responses
            f.response :json # decode response bodies as JSON
            f.response :raise_error, include_request: true
            f.adapter :net_http_persistent, pool_size: 5 do |http|
              # yields Net::HTTP::Persistent
              http.idle_timeout = 100
            end
          end
        end
      end
    end
  end
end
