// focus-trap@7.6.5 downloaded from https://ga.jspm.io/npm:focus-trap@7.6.5/dist/focus-trap.esm.js

import{isFocusable as e,tabbable as t,focusable as n,isTabbable as r,getTabIndex as a}from"tabbable";
/*!
* focus-trap 7.6.5
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/function o(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=Array(t);n<t;n++)r[n]=e[n];return r}function i(e){if(Array.isArray(e))return o(e)}function u(e,t,n){return(t=b(t))in e?Object.defineProperty(e,t,{value:n,enumerable:true,configurable:true,writable:true}):e[t]=n,e}function s(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}function c(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function v(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),true).forEach((function(t){u(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function f(e){return i(e)||s(e)||p(e)||c()}function d(e,t){if("object"!=typeof e||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var r=n.call(e,t);if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}function b(e){var t=d(e,"string");return"symbol"==typeof t?t:t+""}function p(e,t){if(e){if("string"==typeof e)return o(e,t);var n={}.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?o(e,t):void 0}}var m={activateTrap:function(e,t){if(e.length>0){var n=e[e.length-1];n!==t&&n._setPausedState(true)}var r=e.indexOf(t);if(r===-1)e.push(t);else{e.splice(r,1);e.push(t)}},deactivateTrap:function(e,t){var n=e.indexOf(t);n!==-1&&e.splice(n,1);e.length>0&&!e[e.length-1]._isManuallyPaused()&&e[e.length-1]._setPausedState(false)}};var y=function(e){return e.tagName&&e.tagName.toLowerCase()==="input"&&typeof e.select==="function"};var h=function(e){return(e===null||e===void 0?void 0:e.key)==="Escape"||(e===null||e===void 0?void 0:e.key)==="Esc"||(e===null||e===void 0?void 0:e.keyCode)===27};var w=function(e){return(e===null||e===void 0?void 0:e.key)==="Tab"||(e===null||e===void 0?void 0:e.keyCode)===9};var g=function(e){return w(e)&&!e.shiftKey};var N=function(e){return w(e)&&e.shiftKey};var F=function(e){return setTimeout(e,0)};
/**
 * Get an option's value when it could be a plain value, or a handler that provides
 *  the value.
 * @param {*} value Option's value to check.
 * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.
 * @returns {*} The `value`, or the handler's returned value.
 */var O=function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return typeof e==="function"?e.apply(void 0,n):e};var P=function(e){return e.target.shadowRoot&&typeof e.composedPath==="function"?e.composedPath()[0]:e.target};var k=[];var E=function(o,i){var u=(i===null||i===void 0?void 0:i.document)||document;var s=(i===null||i===void 0?void 0:i.trapStack)||k;var c=v({returnFocusOnDeactivate:true,escapeDeactivates:true,delayInitialFocus:true,isKeyForward:g,isKeyBackward:N},i);var l={containers:[],containerGroups:[],tabbableGroups:[],nodeFocusedBeforeActivation:null,mostRecentlyFocusedNode:null,active:false,paused:false,manuallyPaused:false,delayInitialFocusTimer:void 0,recentNavEvent:void 0};var d;
/**
   * Gets a configuration option value.
   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,
   *  value will be taken from this object. Otherwise, value will be taken from base configuration.
   * @param {string} optionName Name of the option whose value is sought.
   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`
   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.
   */var b=function(e,t,n){return e&&e[t]!==void 0?e[t]:c[n||t]};
/**
   * Finds the index of the container that contains the element.
   * @param {HTMLElement} element
   * @param {Event} [event] If available, and `element` isn't directly found in any container,
   *  the event's composed path is used to see if includes any known trap containers in the
   *  case where the element is inside a Shadow DOM.
   * @returns {number} Index of the container in either `state.containers` or
   *  `state.containerGroups` (the order/length of these lists are the same); -1
   *  if the element isn't found.
   */var p=function(e,t){var n=typeof(t===null||t===void 0?void 0:t.composedPath)==="function"?t.composedPath():void 0;return l.containerGroups.findIndex((function(t){var r=t.container,a=t.tabbableNodes;return r.contains(e)||(n===null||n===void 0?void 0:n.includes(r))||a.find((function(t){return t===e}))}))};
/**
   * Gets the node for the given option, which is expected to be an option that
   *  can be either a DOM node, a string that is a selector to get a node, `false`
   *  (if a node is explicitly NOT given), or a function that returns any of these
   *  values.
   * @param {string} optionName
   * @param {Object} options
   * @param {boolean} [options.hasFallback] True if the option could be a selector string
   *  and the option allows for a fallback scenario in the case where the selector is
   *  valid but does not match a node (i.e. the queried node doesn't exist in the DOM).
   * @param {Array} [options.params] Params to pass to the option if it's a function.
   * @returns {undefined | null | false | HTMLElement | SVGElement} Returns
   *  `undefined` if the option is not specified; `null` if the option didn't resolve
   *  to a node but `options.hasFallback=true`, `false` if the option resolved to `false`
   *  (node explicitly not given); otherwise, the resolved DOM node.
   * @throws {Error} If the option is set, not `false`, and is not, or does not
   *  resolve to a node, unless the option is a selector string and `options.hasFallback=true`.
   */var E=function(e){var t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},n=t.hasFallback,r=n!==void 0&&n,a=t.params,o=a===void 0?[]:a;var i=c[e];typeof i==="function"&&(i=i.apply(void 0,f(o)));i===true&&(i=void 0);if(!i){if(i===void 0||i===false)return i;throw new Error("`".concat(e,"` was specified but was not a node, or did not return a node"))}var s=i;if(typeof i==="string"){try{s=u.querySelector(i)}catch(t){throw new Error("`".concat(e,'` appears to be an invalid selector; error="').concat(t.message,'"'))}if(!s&&!r)throw new Error("`".concat(e,"` as selector refers to no known node"))}return s};var T=function(){var t=E("initialFocus",{hasFallback:true});if(t===false)return false;if(t===void 0||t&&!e(t,c.tabbableOptions))if(p(u.activeElement)>=0)t=u.activeElement;else{var n=l.tabbableGroups[0];var r=n&&n.firstTabbableNode;t=r||E("fallbackFocus")}else t===null&&(t=E("fallbackFocus"));if(!t)throw new Error("Your focus-trap needs to have at least one focusable element");return t};var D=function(){l.containerGroups=l.containers.map((function(e){var o=t(e,c.tabbableOptions);var i=n(e,c.tabbableOptions);var u=o.length>0?o[0]:void 0;var s=o.length>0?o[o.length-1]:void 0;var l=i.find((function(e){return r(e)}));var v=i.slice().reverse().find((function(e){return r(e)}));var f=!!o.find((function(e){return a(e)>0}));return{container:e,tabbableNodes:o,focusableNodes:i,posTabIndexesFound:f,firstTabbableNode:u,lastTabbableNode:s,firstDomTabbableNode:l,lastDomTabbableNode:v,
/**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
nextTabbableNode:function(e){var t=!(arguments.length>1&&arguments[1]!==void 0)||arguments[1];var n=o.indexOf(e);return n<0?t?i.slice(i.indexOf(e)+1).find((function(e){return r(e)})):i.slice(0,i.indexOf(e)).reverse().find((function(e){return r(e)})):o[n+(t?1:-1)]}}}));l.tabbableGroups=l.containerGroups.filter((function(e){return e.tabbableNodes.length>0}));if(l.tabbableGroups.length<=0&&!E("fallbackFocus"))throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");if(l.containerGroups.find((function(e){return e.posTabIndexesFound}))&&l.containerGroups.length>1)throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.")};
/**
   * Gets the current activeElement. If it's a web-component and has open shadow-root
   * it will recursively search inside shadow roots for the "true" activeElement.
   *
   * @param {Document | ShadowRoot} el
   *
   * @returns {HTMLElement} The element that currently has the focus
   **/var G=function(e){var t=e.activeElement;if(t)return t.shadowRoot&&t.shadowRoot.activeElement!==null?G(t.shadowRoot):t};var x=function(e){if(e!==false&&e!==G(document))if(e&&e.focus){e.focus({preventScroll:!!c.preventScroll});l.mostRecentlyFocusedNode=e;y(e)&&e.select()}else x(T())};var S=function(e){var t=E("setReturnFocus",{params:[e]});return t||t!==false&&e};
/**
   * Finds the next node (in either direction) where focus should move according to a
   *  keyboard focus-in event.
   * @param {Object} params
   * @param {Node} [params.target] Known target __from which__ to navigate, if any.
   * @param {KeyboardEvent|FocusEvent} [params.event] Event to use if `target` isn't known (event
   *  will be used to determine the `target`). Ignored if `target` is specified.
   * @param {boolean} [params.isBackward] True if focus should move backward.
   * @returns {Node|undefined} The next node, or `undefined` if a next node couldn't be
   *  determined given the current state of the trap.
   */var R=function(t){var n=t.target,o=t.event,i=t.isBackward,u=i!==void 0&&i;n=n||P(o);D();var s=null;if(l.tabbableGroups.length>0){var v=p(n,o);var f=v>=0?l.containerGroups[v]:void 0;if(v<0)s=u?l.tabbableGroups[l.tabbableGroups.length-1].lastTabbableNode:l.tabbableGroups[0].firstTabbableNode;else if(u){var d=l.tabbableGroups.findIndex((function(e){var t=e.firstTabbableNode;return n===t}));d<0&&(f.container===n||e(n,c.tabbableOptions)&&!r(n,c.tabbableOptions)&&!f.nextTabbableNode(n,false))&&(d=v);if(d>=0){var b=d===0?l.tabbableGroups.length-1:d-1;var m=l.tabbableGroups[b];s=a(n)>=0?m.lastTabbableNode:m.lastDomTabbableNode}else w(o)||(s=f.nextTabbableNode(n,false))}else{var y=l.tabbableGroups.findIndex((function(e){var t=e.lastTabbableNode;return n===t}));y<0&&(f.container===n||e(n,c.tabbableOptions)&&!r(n,c.tabbableOptions)&&!f.nextTabbableNode(n))&&(y=v);if(y>=0){var h=y===l.tabbableGroups.length-1?0:y+1;var g=l.tabbableGroups[h];s=a(n)>=0?g.firstTabbableNode:g.firstDomTabbableNode}else w(o)||(s=f.nextTabbableNode(n))}}else s=E("fallbackFocus");return s};var j=function(e){var t=P(e);p(t,e)>=0||(O(c.clickOutsideDeactivates,e)?d.deactivate({returnFocus:c.returnFocusOnDeactivate}):O(c.allowOutsideClick,e)||e.preventDefault())};var I=function(e){var t=P(e);var n=p(t,e)>=0;if(n||t instanceof Document)n&&(l.mostRecentlyFocusedNode=t);else{e.stopImmediatePropagation();var r;var o=true;if(l.mostRecentlyFocusedNode)if(a(l.mostRecentlyFocusedNode)>0){var i=p(l.mostRecentlyFocusedNode);var u=l.containerGroups[i].tabbableNodes;if(u.length>0){var s=u.findIndex((function(e){return e===l.mostRecentlyFocusedNode}));if(s>=0)if(c.isKeyForward(l.recentNavEvent)){if(s+1<u.length){r=u[s+1];o=false}}else if(s-1>=0){r=u[s-1];o=false}}}else l.containerGroups.some((function(e){return e.tabbableNodes.some((function(e){return a(e)>0}))}))||(o=false);else o=false;o&&(r=R({target:l.mostRecentlyFocusedNode,isBackward:c.isKeyBackward(l.recentNavEvent)}));x(r||(l.mostRecentlyFocusedNode||T()))}l.recentNavEvent=void 0};var A=function(e){var t=arguments.length>1&&arguments[1]!==void 0&&arguments[1];l.recentNavEvent=e;var n=R({event:e,isBackward:t});if(n){w(e)&&e.preventDefault();x(n)}};var L=function(e){(c.isKeyForward(e)||c.isKeyBackward(e))&&A(e,c.isKeyBackward(e))};var B=function(e){if(h(e)&&O(c.escapeDeactivates,e)!==false){e.preventDefault();d.deactivate()}};var C=function(e){var t=P(e);if(!(p(t,e)>=0)&&!O(c.clickOutsideDeactivates,e)&&!O(c.allowOutsideClick,e)){e.preventDefault();e.stopImmediatePropagation()}};var K=function(){if(l.active){m.activateTrap(s,d);l.delayInitialFocusTimer=c.delayInitialFocus?F((function(){x(T())})):x(T());u.addEventListener("focusin",I,true);u.addEventListener("mousedown",j,{capture:true,passive:false});u.addEventListener("touchstart",j,{capture:true,passive:false});u.addEventListener("click",C,{capture:true,passive:false});u.addEventListener("keydown",L,{capture:true,passive:false});u.addEventListener("keydown",B);return d}};var _=function(){if(l.active){u.removeEventListener("focusin",I,true);u.removeEventListener("mousedown",j,true);u.removeEventListener("touchstart",j,true);u.removeEventListener("click",C,true);u.removeEventListener("keydown",L,true);u.removeEventListener("keydown",B);return d}};var M=function(e){var t=e.some((function(e){var t=Array.from(e.removedNodes);return t.some((function(e){return e===l.mostRecentlyFocusedNode}))}));t&&x(T())};var U=typeof window!=="undefined"&&"MutationObserver"in window?new MutationObserver(M):void 0;var q=function(){if(U){U.disconnect();l.active&&!l.paused&&l.containers.map((function(e){U.observe(e,{subtree:true,childList:true})}))}};d={get active(){return l.active},get paused(){return l.paused},activate:function(e){if(l.active)return this;var t=b(e,"onActivate");var n=b(e,"onPostActivate");var r=b(e,"checkCanFocusTrap");r||D();l.active=true;l.paused=false;l.nodeFocusedBeforeActivation=G(u);t===null||t===void 0||t();var a=function(){r&&D();K();q();n===null||n===void 0||n()};if(r){r(l.containers.concat()).then(a,a);return this}a();return this},deactivate:function(e){if(!l.active)return this;var t=v({onDeactivate:c.onDeactivate,onPostDeactivate:c.onPostDeactivate,checkCanReturnFocus:c.checkCanReturnFocus},e);clearTimeout(l.delayInitialFocusTimer);l.delayInitialFocusTimer=void 0;_();l.active=false;l.paused=false;q();m.deactivateTrap(s,d);var n=b(t,"onDeactivate");var r=b(t,"onPostDeactivate");var a=b(t,"checkCanReturnFocus");var o=b(t,"returnFocus","returnFocusOnDeactivate");n===null||n===void 0||n();var i=function(){F((function(){o&&x(S(l.nodeFocusedBeforeActivation));r===null||r===void 0||r()}))};if(o&&a){a(S(l.nodeFocusedBeforeActivation)).then(i,i);return this}i();return this},pause:function(e){if(!l.active)return this;l.manuallyPaused=true;return this._setPausedState(true,e)},unpause:function(e){if(!l.active)return this;l.manuallyPaused=false;return s[s.length-1]!==this?this:this._setPausedState(false,e)},updateContainerElements:function(e){var t=[].concat(e).filter(Boolean);l.containers=t.map((function(e){return typeof e==="string"?u.querySelector(e):e}));l.active&&D();q();return this}};Object.defineProperties(d,{_isManuallyPaused:{value:function(){return l.manuallyPaused}},_setPausedState:{value:function(e,t){if(l.paused===e)return this;l.paused=e;if(e){var n=b(t,"onPause");var r=b(t,"onPostPause");n===null||n===void 0||n();_();q();r===null||r===void 0||r()}else{var a=b(t,"onUnpause");var o=b(t,"onPostUnpause");a===null||a===void 0||a();D();K();q();o===null||o===void 0||o()}return this}}});d.updateContainerElements(o);return d};export{E as createFocusTrap};

